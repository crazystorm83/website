{
  "version": 3,
  "sources": ["../../src/05.browser_foundation/exception/ThrowException.ts", "../../src/05.browser_foundation/data/Register.ts", "../../src/05.browser_foundation/data/storage/Storage.ts", "../../src/05.browser_foundation/data/storage/InstanceStorage.ts", "../../src/10.browser_infra/datas/EventInstanceStorage.ts", "../../src/10.browser_infra/decorators/NHEventHandler.ts", "../../src/10.browser_infra/datas/NodeInstanceStorage.ts", "../../src/10.browser_infra/decorators/NHNode.ts", "../../src/02.foundation/utils/createUID.ts", "../../src/10.browser_infra/nodes/Node.ts"],
  "sourcesContent": ["export function throwException(condition: boolean,message: string): asserts condition {\r\n    if (condition) {\r\n        return;\r\n    }\r\n    \r\n    throw new Error(message);\r\n}", "import { throwException } from \"../exception/ThrowException\";\r\n\r\nexport interface IRegisterItem {\r\n    getType(): string;\r\n}\r\n\r\nexport interface IRegister<T> {\r\n    add(key: string, target: T): void;\r\n    get(type: string): T | undefined;\r\n    getOrThrow(type: string): T;\r\n    getAll(): T[];\r\n}\r\nexport class Register<T> implements IRegister<T> {\r\n    __items: Map<string, T> = new Map();\r\n    add<V extends T>(key: string, target: V): void {\r\n        this.__items.set(key, target);\r\n    }\r\n\r\n    get(type: string): T | undefined {\r\n        return this.__items.get(type);\r\n    }\r\n\r\n    getOrThrow(type: string): T {\r\n        const item = this.get(type);\r\n        if (!item) {\r\n            throwException(false, `Item with type ${type} not found`);\r\n        }\r\n        return item;\r\n    }\r\n\r\n    getAll(): T[] {\r\n        return Array.from(this.__items.values());\r\n    }\r\n}\r\n\r\n", "import { IStorage } from \"../../@types/data/storage/IStorage\";\r\nimport { throwException } from \"../../exception/ThrowException\";\r\nimport { Register } from \"../Register\";\r\n\r\nexport abstract class Storage<T> extends Register<T> implements IStorage<T> {\r\n    protected _instances: Map<string, T> = new Map();\r\n\r\n    add<V extends T>(key: string, target: V): void {\r\n        super.add(key, target);\r\n    }\r\n\r\n    get(key: string): T | undefined {\r\n        const item = super.get(key);\r\n        if (!item) return undefined;\r\n\r\n        if (this._instances.has(key)) {\r\n            return this._instances.get(key) as T;\r\n        }\r\n\r\n        const instance = new (item as any)();\r\n        this._instances.set(key, instance);\r\n        return instance;\r\n    }\r\n    getOrThrow(key: string): T {\r\n        const item = this.get(key);\r\n        if (!item) {\r\n            throwException(false, `Item with key ${key} not found`);\r\n        }\r\n\r\n        if (this._instances.has(key)) {\r\n            return this._instances.get(key) as T;\r\n        }\r\n        const instance = new (item as any)();\r\n        this._instances.set(key, instance);\r\n        return instance;\r\n    }\r\n}", "import { IInstanceStorage } from \"../../@types/data/storage/IInstanceStorage\";\r\nimport { Storage } from \"./Storage\";\r\n\r\nexport abstract class InstanceStorage<T> extends Storage<T> implements IInstanceStorage<T> {\r\n\r\n}\r\n", "import { IRegisterItem } from \"../../05.browser_foundation/@types/data/IRegister\";\r\nimport { InstanceStorage } from \"../../05.browser_foundation/data/storage/InstanceStorage\";\r\n\r\nexport class EventInstanceStorage<T extends IRegisterItem> extends InstanceStorage<T> {\r\n}", "import { EventHandlers, Identifier } from \"@primitive_types\";\r\nimport { EventInstanceStorage } from \"../datas/EventInstanceStorage\";\r\n\r\nexport const eventInstanceStorage = new EventInstanceStorage<EventHandlers.EventHandler>();\r\n\r\nexport function NHEventHandler({\r\n    nodeIdentifier,\r\n}: {\r\n    nodeIdentifier: Identifier;\r\n}) {\r\n    return function <T extends typeof EventHandlers.EventHandler>(constructor: T): void {\r\n        eventInstanceStorage.add(nodeIdentifier.type, constructor as unknown as EventHandlers.EventHandler);\r\n    }\r\n}", "import { IRegisterItem } from \"../../05.browser_foundation/@types/data/IRegister\";\r\nimport { InstanceStorage } from \"../../05.browser_foundation/data/storage/InstanceStorage\";\r\n\r\nexport class NodeInstanceStorage<T extends IRegisterItem> extends InstanceStorage<T> {\r\n}", "import { Identifier, INode } from \"@primitive_types\";\r\nimport { NodeInstanceStorage } from \"../datas/NodeInstanceStorage\";\r\n\r\nexport const nodeInstanceStorage = new NodeInstanceStorage<any>();\r\n\r\nexport function NHNode({\r\n    identifier,\r\n}: {\r\n    identifier: Identifier;\r\n}) {\r\n    return <T extends abstract new (...args: any[]) => INode>(constructor: T): void => {\r\n        nodeInstanceStorage.add(identifier.type, constructor);\r\n    }\r\n}\r\n", "const UIdMap = new Map<string, number>();\r\n\r\nexport function createNodeSequentialUID(): string {\r\n    const uidKey = 'node';\r\n    return createSequentialUID(uidKey);\r\n}\r\n\r\nexport function createElementSequentialUID(): string {\r\n    const uidKey = 'element';\r\n    return createSequentialUID(uidKey);\r\n}\r\n\r\nexport function createEditorSequentialUID(): string {\r\n    const uidKey = 'editor';\r\n    return createSequentialUID(uidKey);\r\n}\r\n\r\nfunction createUID(): string {\r\n    let uuid = 1;\r\n    return (function () {\r\n        //return Math.random().toString(36).substring(2, 15);\r\n        return `uid-${uuid++}`;\r\n    })()\r\n}\r\n\r\nfunction createSequentialUID(uidKey: 'node' | 'element' | 'editor'): string {\r\n    const uid = UIdMap.get(uidKey) ?? 1;\r\n    UIdMap.set(uidKey, uid + 1);\r\n    return `${uidKey}-${uid}`;\r\n}\r\n", "import { createNodeSequentialUID } from \"@foundation/utils\";\r\nimport { ICommand, INode, NodeSerialize, NodeState } from \"@primitive_types\";\r\nimport { throwException } from \"../../05.browser_foundation/exception/ThrowException\";\r\n\r\nexport type Spread<T1, T2> = Omit<T2, keyof T1> & T1;\r\n\r\n// https://github.com/microsoft/TypeScript/issues/3841\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport type KlassConstructor<Cls extends GenericConstructor<any>> =\r\n    GenericConstructor<InstanceType<Cls>> & { [k in keyof Cls]: Cls[k] };\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\ntype GenericConstructor<T> = new (...args: any[]) => T;\r\n\r\n// export type Klass<T extends Node> = InstanceType<\r\n//   T['constructor']\r\n// > extends T\r\n//   ? T['constructor']\r\n//   : GenericConstructor<T> & T['constructor'];\r\n\r\nexport type NodeKey = string;\r\n\r\nexport abstract class Node implements INode {\r\n    __key!: NodeKey;\r\n    __parent: null | NodeKey;\r\n    __prev: null | NodeKey;\r\n    __next: null | NodeKey;\r\n\r\n    __size: number = 0;\r\n\r\n    //['constructor']!: KlassConstructor<typeof Node>;\r\n\r\n    constructor(key?: NodeKey) {\r\n        this.__parent = null;\r\n        this.__prev = null;\r\n        this.__next = null;\r\n        this.__key = key ?? createNodeSequentialUID();\r\n    }\r\n\r\n    _config: NodeSerialize & NodeState<any> | undefined;\r\n\r\n    setConfig(config: NodeSerialize & NodeState<any> | undefined): void {\r\n        this._config = config;\r\n    }\r\n\r\n    createDOM(): HTMLElement | DocumentFragment {\r\n        throwException(false, 'createDOM must be implemented');\r\n    }\r\n\r\n    updateDOM(): boolean {\r\n        throwException(false, 'updateDOM must be implemented');\r\n    }\r\n\r\n    $config() {\r\n\r\n    }\r\n}\r\n\r\n\r\nexport function createCommand(type: string): ICommand {\r\n    return { type }\r\n}"],
  "mappings": "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",
  "names": []
}
